#include "TAcousticPressure.h"
#include "TFFT.h"

#include "TF1.h"
#include "TThread.h"
#include "TUnuran.h"
#include "TUnuranContDist.h"
#include "TUnuranMultiContDist.h"
#include "TUnuranDiscrDist.h"
#include "TUnuranEmpDist.h"
#include "TH3.h"
#include "TF3.h"
#include "TRandom3.h"
#include "TMath.h"
#include "Math/IntegratorMultiDim.h"
#include "Math/WrappedFunction.h"
#include "Math/Integrator.h"

#include <vector>

/******************************************************************************
TFwWrapper
Wrapper functor for the subintegral expression of the Kirchhoff integral depending on detector coordinates,
sound speed, frequency (Fourier spectrum) and energy distribution density
******************************************************************************/

TFwWrapper :: TFwWrapper(const TAcousticPressureParams &params)
{
  SetParams(params);
}

void TFwWrapper :: SetParams(const TAcousticPressureParams &params)
{
	Params = params;
	if (EDD == nullptr || params.Parameterization != EDD->GetParametrization())
		EDD = std::unique_ptr<TEnergyDensityDistribution>(new TEnergyDensityDistribution(params.E0, params.Parameterization, params.TrCutThreshold, params.LonCutThreshold));
  if (abs(EDD->GetE0() - params.E0) < 1e-6)
    EDD->SetE0(params.E0);
}

fp TFwWrapper :: operator () (const fp phi, const fp r, const fp z) const
{
	const/*constexpr?*/ fp dl = sqrt( pow(Params.Rd, fp(2.)) + pow(r, fp(2.)) + pow(Params.Zd - z, fp(2.)) - 2 * Params.Rd * r * cos(phi) );
  //fp d = sqrt( pow(Rd,2) + pow(r,2) + pow(Zd-z,2) );
  if (Params.PartOfComplexNumber == TPartOfComplexNumber::Re)
    return r * (*EDD)(r,z) * sin(Params.w * dl / Params.cs) / dl ; //d
  else
    return r * (*EDD)(r,z) * cos(Params.w * dl / Params.cs) / dl ; //d
}

//Root 		r = *arg;	z = *(arg + 1);	phi = *(arg + 2);
Double_t TFwWrapper::operator ()(const Double_t * arg)
{
  const fp r = *arg,
	         z = *(arg + 1),
           phi = *(arg + 2);
  return (*this)(phi, r, z);
}

TEnergyDensityDistribution * TFwWrapper :: GetEDD() const noexcept
{
  return EDD.get();
}

/******************************************************************************
TAcousticPressure
Base class for calculating the acoustic pressure generated by the hadron cascade
with energy density distribution
******************************************************************************/

//Set experiment conditions
void TAcousticPressure :: SetConditions(const TAcousticPressureParams &conditions)
{
	if (FwWrapper == nullptr)
		FwWrapper = std::unique_ptr<TFwWrapper>(new TFwWrapper(conditions));

	FwWrapper->SetParams(conditions);
	LMax = EvaluateLMax();
}

//Returns the linear coordinate of the maximum of the cascade
fp TAcousticPressure :: EvaluateLMax()
{
	fp result = 0;
  //TF1 в моей версии ROOT непотокобезопасна и вызывает поломку памяти
  //при многопоточном использовании, поэтому блокируем мьютексом главный поток
  TThread::Lock();
  try {
    TEnergyDensityDistribution * edd = FwWrapper->GetEDD();
		auto redl = [edd](const double * x, const double * p){ return (*edd)(1., x[0]); };

    TF1 fredl("REDL", redl, 0., FwWrapper->GetParams().LonCutThreshold, 1);
    result = static_cast<fp>(fredl.GetMaximumX(0., FwWrapper->GetParams().LonCutThreshold));
  } catch (std::exception &e){
    TThread::UnLock();
    throw e;
  };
  TThread::UnLock();
  return result;
}

//Ряд значений из N точек акустического эффекта (на данной частоте w) развития ЯЭК в точке распложения детектора (Rd,Zd)
//Спектр акустического импульса, ограниченный частотой fmax
void TAcousticPressure :: GetComplexPwSeries(	const fp &rd,
                                              const fp &zd,
                                              fp &fmax,
                                              size_t N,
                                              std::vector<std::complex<fp>> &pwx,		//Комплексный спектр
                                              std::vector<fp> &mpwx                 //Модуль спектра
                                            )
{
  if (pwx.size() != N)
    pwx.resize(N);

  if (mpwx.size() != N)
    mpwx.resize(N);

  for (size_t i = 0; i < N; i++)
  {
		fp w = fp(i) * fmax * 2. * TMath::Pi() / N;
		pwx[i] = this->GetComplexPwValue(rd, zd, w);
		mpwx[i] = sqrt(pow(pwx[i].real(), fp(2.)) + pow(pwx[i].imag(), fp(2.)));
  };
}

//Acoustic pressure depending on time
void TAcousticPressure :: GetPtSeries(	std::vector<std::complex<fp>> &pwx,
                                        std::vector<fp> &pt,
																				fp &fmax,												//Can be used by inheritor
                                        size_t N
                                      )
{
  //!!!to class variables
	TFFT fft({TFFTOperation::C2R_BACKWARD, TFFTNormalization::TWO_SIDED, static_cast<int>(N)});

  //!!!to class variables
  std::vector<Double_t> re_pwx(N),
                        im_pwx(N),
                        pt_out(N);

  CA2DATA(pwx, re_pwx, im_pwx);

  fft(re_pwx.data(), im_pwx.data(), pt_out.data());

  if (pt.size() != N)
		pt.resize(N);
	#pragma omp parallel for
  for (size_t i = 0; i < pt_out.size(); i++)
		pt[i] = static_cast<fp>(pt_out[i]);											// *fmax;    //Исключается зависимость от частоты дискретизации и !!!
}


/******************************************************************************
TMCICAP
///Monte Carlo method
/// S. Bevan, S. Danaher, J. Perkin, S. Ralph, C. Rhodes, L. Thompson, T. Sloan, D. Waters.
/// Simulation of Ultra High Energy Neutrino Interactions in Ice and Water.
/// Astroparticle Physics, Volume 28, Issue 3, p. 366-379. 2007. ELSEVIER.
/// DOI:10.1016/j.astropartphys.2007.08.001. arXiv:0704.1025.
******************************************************************************/

TMCICAP :: TMCICAP(const int npoints) : TAcousticPressure()
{
  NPoints = npoints;
}

//This function not used
std::complex<fp> TMCICAP :: GetComplexPwValue (const fp &rd, const fp &zd, const fp &w)
{
  return std::complex<fp>();
}

//Ряд значений из N точек акустического эффекта (на данной частоте w) развития ЯЭК в точке распложения детектора (Rd,Zd)
//Спектр акустического импульса, ограниченный частотой fmax
//Используется генератор псевдослучайной последовательности Mersenne Twister
//Для построения распределения с заданной плотностью используется метод HITRO – Markov Chain - HIT-and-run sampler with Ratio-Of-uniforms
//Вычисление, по-видимому, можно ускорить, если помимо pdf задать еще и производную от нее, сейчас он ищет численно
void TMCICAP :: GetComplexPwSeries(	const fp &rd,
																		const fp &zd,
																		fp &fmax,
																		size_t N,
																		std::vector<std::complex<fp>> &pwx,		//Комплексный спектр
																		std::vector<fp> &mpwx,                //Модуль спектра
																		TH3D * edd3d,
																		TH2D * edd2d
){
  const fp d = sqrt(pow(rd, fp(2.)) +  pow(zd, fp(2.)));

  //Инициализируем класс для работы со случайными последовательностями заданного распределения
  //нашей функцией распределения энергии в каскаде - EDD. Используется генератор псевдослучайной
  //последовательности Mersenne Twister метод HITRO – Markov Chain - HIT-and-run sampler with Ratio-Of-uniforms
  TF3 f(
        "g3d",
        FwWrapper->GetEDD(),
        -FwWrapper->GetParams().TrCutThreshold,
        FwWrapper->GetParams().TrCutThreshold,
        -FwWrapper->GetParams().TrCutThreshold,
        FwWrapper->GetParams().TrCutThreshold,
        0,
        FwWrapper->GetParams().LonCutThreshold,
        0
      );

  TUnuranMultiContDist dist(&f);
  TRandom3 twister_gen;	//Mersenne Twister
  TUnuran unr(&twister_gen);
  std::string method = "method=hitro; use_boundingrectangle=false; use_adaptiveline=true; variant_coordinate";//"method=hitro; use_boundingrectangle=true ";
  if (!unr.Init(dist, method))
		throw std::runtime_error("TMCICAP :: GetComplexPwSeries error: Error initializing unuran");

  fp bin_width = 1./(2.*fmax);	//По определению
  //Это ширина бина не Et, а восстановленного Pt
  fp htau = d/FwWrapper->GetParams().cs + bin_width*N/2;
  fp ltau = d/FwWrapper->GetParams().cs - bin_width*N/2;

  //Набрасываем гистограмму времен прихода из каждой точки
  TH1D Et("Et", "Et-title", static_cast<int>(N) * 2, ltau, htau);
	//!!!#pragma omp parallel for
	for (int i = 0; i < NPoints; i++)
  {
		double x[3];
    unr.SampleMulti(x);				//get new x

		if (edd3d != nullptr)
			edd3d->Fill(x[0],x[1],x[2]);
		if (edd2d != nullptr)
			edd2d->Fill(x[0],x[2]);

		fp r = sqrt(pow(x[0], 2.) + pow(x[1], 2.));
		fp z = x[2];
		fp tau = sqrt(pow(rd - r, 2) +  pow(zd - z, 2)) / FwWrapper->GetParams().cs;
    if ((tau > ltau) && (tau < htau))
      Et.Fill(tau);
    else
      i--;
	}

	fp Omega = 2. * TMath::Pi() * fmax; //
	std::vector<Double_t> arr_etv(N * 2),
												arr_re_pw(N * 2),
												arr_im_pw(N * 2);
  for (size_t i = 0; i < N; i++)
    arr_etv[i] = Et.GetBinContent(static_cast<int>(i)) * 1./(bin_width * NPoints) ;

	TFFT fft({TFFTOperation::R2C_FORWARD, TFFTNormalization::TWO_SIDED, static_cast<int>(N * 2)});
	fft(arr_re_pw.data(), arr_im_pw.data(), arr_etv.data());
	//!!!#pragma omp parallel for
	for (size_t i = 0; i < N; i++)		//  *iwn
  {
    //есть множитель i => (0 + i*1)*(re + i*im) = -im + i*re
    pwx[i].real(arr_re_pw[i]);
    pwx[i].imag(arr_im_pw[i]);
		pwx[i] = /*std::complex<fp>(0, 1) * */ pwx[i] * (1. / d * FwWrapper->GetParams().E0 * fp(i/*+1*/)/**Omega*//N);
    mpwx[i] = sqrt(pow(pwx[i].real(), fp(2.)) + pow(pwx[i].imag(), fp(2.)));
	}

  fmax = Omega/(2.*TMath::Pi());
}
